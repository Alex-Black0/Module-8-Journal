# Module-8-Journal

Reflection – CS 320: Software Test, Automation
Throughout the CS 320 course, I gained practical experience in designing, implementing, and testing software solutions with a focus on quality assurance and automation. In Project One, I created and tested a contact service using Java and JUnit, developing the necessary classes and writing unit tests to validate functionality. In Project Two, I reflected on my testing strategy and the role of software automation in quality assurance. These artifacts demonstrate my ability to design code that is not only functional, but also robust and testable.

To ensure that my code is functional and secure, I follow a test-driven development mindset. I begin by understanding the functional requirements and writing unit tests that validate each method’s behavior. By using JUnit testing, I can repeatedly run test cases to catch regressions early and confirm that updates do not break existing functionality. I also prioritize input validation and exception handling to minimize vulnerabilities and ensure code reliability.

When interpreting user needs, I focus on translating requirements into practical specifications. I read the project prompts carefully, identify functional constraints (such as character limits or uniqueness requirements), and then build my classes to align with those specifications. This helps ensure that the software behaves in a way that meets user expectations while maintaining code integrity.

My approach to designing software begins with planning and abstraction. I think about the problem domain and break it down into logical classes and methods. I design with modularity in mind so that each component can be tested individually. I also use consistent naming conventions, comments, and clean structure to make my code easier to understand and maintain.

This course strengthened my skills in automated testing and gave me insight into the evolving role of QA engineers in software development. I am proud to include these projects in my portfolio as they demonstrate my growing proficiency in writing reliable, maintainable, and well-tested code.
